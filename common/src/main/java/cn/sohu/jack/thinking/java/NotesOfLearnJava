第一章 对象导论
1、我们将问题空间的元素以及其在解空间的表示称为 对象
2、类实际上就是数据类型
3、设计难点：问题空间的元素和解空间的对象创建一对一的关系
4、UML图 统一建模类型
5、当你开发一个程序设计是，最好的方法是把对象当作 “服务提供者”
6、高内聚是软件设计的基本质量要求之一
7、访问控制 （1）可以让客户端程序员无法触及隐藏的部分；（2）可以让库设计者可以任意调整后 台程序设计而不影响客户端的使用；
8、projected与private作用相当，projected 只是在继承中可以被引用
9、一个非面向对象编程的编译器产生的函数调用运用前期绑定，编译器将会产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行代码的绝对地址
     面向对象编程使用了后期绑定，当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确认调用方法的存在，检查调用参数和返回值的类型。
     ******特殊代码使用在对象中存储的信息来计算方法体的地址****** java中方法的动态绑定时默认的

10、容器选择：（1）不同的容器提供了不同的接口和外部行为
                           (2) 不同的容器执行某些操作时会有不同的效率
11、堆中动态管理存储空间，在运行时需要对象才去分配空间，而不是编译时在堆栈中创建对象，分配内存可能比创建对象更耗时！
12、垃圾回收器提供了更高层的保障，避免了内存泄漏问题（Wikipedia 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。
    内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费）

第二章 一切都是对象
1、存储数据的地方：寄存器，堆栈，堆，常量存储，非RAM存储
    堆栈：位于通用RAM；指针下移分配新的内存，上移释放内存 创建程序时，Java系统必须知道存储在堆栈中所有项的生命周期，限制了语言的灵活性，
    某些java数据存储在对象中--特别时对象引用 Java对象不存在其中
存储基本类型（变量直接存储值）
    堆：通用的内存池，存放所有的Java对象
    非RAM存储：流对象和持久化对象
2、若返回值为空，则return 的作用就是用来退出方法而已
3、static 解决了只想为某特定域分配单一内存空间；而不去关注究竟要创建多少对象。
                 方法不与关联它的对象实例产生关系，没有创建对象，也能调用这个方法
4、javadoc 文档格式化工具
5、自动包装器对基本类型和包装器类型自动装箱

第三章 操作符
1、System.out.println*() 这种特定上下文环境中 String类型的 + 操作连接，意味着”字符串连接“，会自动将非String的转化为 String
2、基本类型赋值是存储了实际的数值，而并非指向一个对象的引用，为其赋值的时候是直接将一个数从一个地方复制到另外一个地方，
3、如果在应当使用String值的地方使用了布尔值，则boolean类型的值会相应的转变为文本类型
4、按位操作符 (&) 两个输入位都是1，则输出1 否则输出0；按位操作符（|）有一个是1 输出1，按位异或(^) 其中一个是1，但不全是1则输出1 按位非 取反操作。
可以和=号联合操作，&=, |=, ^= 都是合法的
5、<<有符号左移 >>有符号右移（右移时符号为-时，高位补1）
6、三元操作符 if-else boolean-exp?value1:value2
7、类型转换运算符允许我们显式地进行这种类型转化；但窄化转化是不被允许的，除布尔型的基本类型都能进行类型转化

第四章 控制执行流程
1、重载表示相同的方法名可以具有不同的参数列表
2、如果方法是void的，那么方法体内就会相应有一个隐式的return，所以不是所有的方法都要写return

第五章 初始化和清理
1、当创建了一个对象时，也就给此分配到的存储空间取了一个名字
2、构造器方法重载
3、在构造器中调用构造器
4、static 方法内部是不能调用非静态方法的，反之可以
5、初始化的顺序是静态对象 后是非静态对象。

6、1）对象可能不被垃圾回收
   2）垃圾回收不等同于析构
   3）垃圾回收只与内存有关
7、垃圾回收器对于提高对象的创建速度，有明显的效果。堆内一面回收空间，一面使对象可以紧凑排列。
8、对象引用计数的为零的回收缺陷：对象之间存在循环引用，可能会出现“对像应该被回收，但引用不为零的情况”
   对垃圾回收器而言，定位这样的交互引用对象组所需的工作量极大。
9、垃圾回收器的另外一种模式，对任何活的对象，一定能最终追溯到其存活在堆栈或静态存储区中的引用 ，当完全没引用时回收（解决了对象交互引用的缺陷）
   对此垃圾回收器将采用自适应的垃圾回收技术，如何找到存活的对象则取决于具体的java虚拟机实现。
   自适应的，分代的，停止-复制，标记-清扫 式垃圾回收器
即时编译器和惰性评估（即时编译器在必要的时候才对对象进行编译）
10、对象的创建过程：
 1-定位dog.class 文件
 2-载入Dog.class（这将创建一个class对象） 有关静态初始化的所以动作都会执行，静态初始化只在Class对象首次加载时进行一次
 3-当用new Dog() 创建对象时，会在堆上为其分配足够的内存空间
 4-这块存储空间会被清零，类中引用到的所有的基本类型会设置为默认值，而引用则设置为null
 5-执行所有出现在字段定义处的初始化动作
 6-执行构造器
11、静态子句 static {}; static 不能应用在局部变量，例如main方法中

第六章 访问权限控制
1、包内包含有一组类，它们在单一的名字空间内被组织在一起
2、每个编译单元只能有一个public类
3、protected 也有包内访问权限
4、
第七章 复用类
1、方法重载（Override）的子方法必须和父方法同名称 返回类型 形参(除协变返回类型外)
2、一个即是static又是final的域只占据一段不能改变的存储空间
3、final 修饰的方法 第一 防止继承类修改父类方法的含义，覆盖也不可以（在明确需要禁止覆盖时才写，会降低执行效率）
4、final 类不能被继承（一般出于严格的安全考虑才会选择final修饰类）
5、类的代码在初次使用时才会被加载
6、总结：程序开发是一个增量过程，犹如人类的学习一样，程序开发是依赖于实验，你只能尽可能的去计算所有可能发生的结果，
       而不能将所有的结果都拿到，项目视为一个有机的、进化的生命体。

第八章 多态
1、多态是分离做什么和怎么做，从另一个角度将接口和实现分离出来，不同类型根据实现方法的不同运行时有不同的动作
   作用是消除不同类型间的耦合。
2、java 中除了static和final（private算final）方法外，其他方法都默认是后期绑定（运行时绑定）
3、域与静态方法不能用多态
4、域访问操作由编译器解析，所以不具有多态性 通常将基类中的域设置为private，因此不能直接访问他们，只能通过方法来访问
5、在构造器内部调用导出类覆盖的方法时，方法内用到的成员变量还未初始化，可能会导致错误
6、初始化的实际进程：1> 先会给对象分配的存储空间初始化成二进制的零
                 2> 调用基类构造器，
                 3> 按照声明的顺序调用成员的初始化方法
                 4> 调用导出类的构造器主体

第九章 接口
1、抽象方法是仅有方法名，而没有方法体
2、抽象类：包含抽象方法的类叫抽象类，类包含一个或多个抽象方法，类必须是抽象的，否则编译器会报错；它是普通类和接口的中庸之道，
3、创建抽象类和抽象方法非常有用，能使共同的特性抽象起来，告诉用户和编译器如何使用他们。
4、接口也可以包含域，域是隐式的static和final