第一章 对象导论
1、我们将问题空间的元素以及其在解空间的表示称为 对象
2、类实际上就是数据类型
3、设计难点：问题空间的元素和解空间的对象创建一对一的关系
4、UML图 统一建模类型
5、当你开发一个程序设计是，最好的方法是把对象当作 “服务提供者”
6、高内聚是软件设计的基本质量要求之一
7、访问控制 （1）可以让客户端程序员无法触及隐藏的部分；（2）可以让库设计者可以任意调整后 台程序设计而不影响客户端的使用；
8、projected与private作用相当，projected 只是在继承中可以被引用
9、一个非面向对象编程的编译器产生的函数调用运用前期绑定，编译器将会产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行代码的绝对地址
     面向对象编程使用了后期绑定，当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确认调用方法的存在，检查调用参数和返回值的类型。
     ******特殊代码使用在对象中存储的信息来计算方法体的地址****** java中方法的动态绑定时默认的

10、容器选择：（1）不同的容器提供了不同的接口和外部行为
                           (2) 不同的容器执行某些操作时会有不同的效率
11、堆中动态管理存储空间，在运行时需要对象才去分配空间，而不是编译时在堆栈中创建对象，分配内存可能比创建对象更耗时！
12、垃圾回收器提供了更高层的保障，避免了内存泄漏问题（Wikipedia 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。
    内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费）

第二章 一切都是对象
1、存储数据的地方：寄存器，堆栈，堆，常量存储，非RAM存储
    堆栈：位于通用RAM；指针下移分配新的内存，上移释放内存 创建程序时，Java系统必须知道存储在堆栈中所有项的生命周期，限制了语言的灵活性，
    某些java数据存储在对象中--特别时对象引用 Java对象不存在其中
存储基本类型（变量直接存储值）
    堆：通用的内存池，存放所有的Java对象
    非RAM存储：流对象和持久化对象
2、若返回值为空，则return 的作用就是用来退出方法而已
3、static 解决了只想为某特定域分配单一内存空间；而不去关注究竟要创建多少对象。
                 方法不与关联它的对象实例产生关系，没有创建对象，也能调用这个方法
4、javadoc 文档格式化工具
5、自动包装器对基本类型和包装器类型自动装箱

第三章 操作符
1、System.out.println*() 这种特定上下文环境中 String类型的 + 操作连接，意味着”字符串连接“，会自动将非String的转化为 String
2、基本类型赋值是存储了实际的数值，而并非指向一个对象的引用，为其赋值的时候是直接将一个数从一个地方复制到另外一个地方，
3、如果在应当使用String值的地方使用了布尔值，则boolean类型的值会相应的转变为文本类型
4、按位操作符 (&) 两个输入位都是1，则输出1 否则输出0；按位操作符（|）有一个是1 输出1，按位异或(^) 其中一个是1，但不全是1则输出1 按位非 取反操作。
可以和=号联合操作，&=, |=, ^= 都是合法的
5、<<有符号左移 >>有符号右移（右移时符号为-时，高位补1）
6、三元操作符 if-else boolean-exp?value1:value2
7、类型转换运算符允许我们显式地进行这种类型转化；但窄化转化是不被允许的，除布尔型的基本类型都能进行类型转化

第四章 控制执行流程
1、重载表示相同的方法名可以具有不同的参数列表
2、如果方法是void的，那么方法体内就会相应有一个隐式的return，所以不是所有的方法都要写return
3、1> 一般情况下continue会回退到最内层循环的开头，继续执行循环
   2> 带标签的continue会进入到达标签的位置，并重新进入哪个标签后面的循环
   3> 一般break会中断并跳出当前循环
   4> 带标签的break会中断并跳出标签所指的那个循环

第五章 初始化和清理
1、当创建了一个对象时，也就给此分配到的存储空间取了一个名字
2、构造器方法重载 方法重载，以参数的方式
  不能以返回值的方式重载方法，因为写一个方法名不知道调用哪一个
3、在构造器中调用构造器 可以用this调用构造器，但不能调用两个，必须将构造器置于最起始处
   在类定义中，除构造器外，编译器禁止类内其它任何方法调用构造器
4、static 方法内部是不能调用非静态方法的，反之可以
5、初始化的顺序是静态对象 后是非静态对象。

6、1）对象可能不被垃圾回收
   2）垃圾回收不等同于析构
   3）垃圾回收只与内存有关
7、垃圾回收器对于提高对象的创建速度，有明显的效果。堆内一面回收空间，一面使对象可以紧凑排列。
8、对象引用计数的为零的回收缺陷：对象之间存在循环引用，可能会出现“对像应该被回收，但引用不为零的情况”
   对垃圾回收器而言，定位这样的交互引用对象组所需的工作量极大。
9、垃圾回收器的另外一种模式，对任何活的对象，一定能最终追溯到其存活在堆栈或静态存储区中的引用 ，当完全没引用时回收（解决了对象交互引用的缺陷）
   对此垃圾回收器将采用自适应的垃圾回收技术，如何找到存活的对象则取决于具体的java虚拟机实现。
   自适应的，分代的，停止-复制，标记-清扫式垃圾回收器
即时编译器和惰性评估（即时编译器在必要的时候才对对象进行编译）
10、对象的创建过程：
 1-定位dog.class 文件
 2-载入Dog.class（这将创建一个class对象） 有关静态初始化的所以动作都会执行，静态初始化只在Class对象首次加载时进行一次
 3-当用new Dog() 创建对象时，会在堆上为其分配足够的内存空间
 4-这块存储空间会被清零，类中引用到的所有的基本类型会设置为默认值，而引用则设置为null
 5-执行所有出现在字段定义处的初始化动作
 6-执行构造器
11、静态子句 static {}; static 不能应用在局部变量，例如main方法中
12、枚举的方法 ordinal()表示特定常量的声明顺序 static values()按照enum常量的声明顺序，产生由这些常量值构成的数组

第六章 访问权限控制
1、包内包含有一组类，它们在单一的名字空间内被组织在一起
2、每个编译单元只能有一个public类
3、protected 也有包内访问权限
4、
第七章 复用类
1、方法重载（Override）的子方法必须和父方法同名称 返回类型 形参(除协变返回类型外)
2、一个即是static又是final的域只占据一段不能改变的存储空间
3、final 修饰的方法 第一 防止继承类修改父类方法的含义，覆盖也不可以（在明确需要禁止覆盖时才写，会降低执行效率）
4、final 类不能被继承（一般出于严格的安全考虑才会选择final修饰类）
5、类的代码在初次使用时才会被加载
6、总结：程序开发是一个增量过程，犹如人类的学习一样，程序开发是依赖于实验，你只能尽可能的去计算所有可能发生的结果，
       而不能将所有的结果都拿到，项目视为一个有机的、进化的生命体。

第八章 多态

1、多态是分离做什么和怎么做，从另一个角度将接口和实现分离出来，不同类型根据实现方法的不同运行时有不同的动作
   作用是消除不同类型间的耦合。
2、java 中除了static和final（private算final）方法外，其他方法都默认是后期绑定（运行时绑定）
3、域与静态方法不能用多态
4、域访问操作由编译器解析，所以不具有多态性 通常将基类中的域设置为private，因此不能直接访问他们，只能通过方法来访问
5、在构造器内部调用导出类覆盖的方法时，方法内用到的成员变量还未初始化，可能会导致错误
6、初始化的实际进程：1> 先会给对象分配的存储空间初始化成二进制的零
                 2> 调用基类构造器，
                 3> 按照声明的顺序调用成员的初始化方法
                 4> 调用导出类的构造器主体
7、构造器实际上是隐式的static方法

第九章 接口
1、抽象方法是仅有方法名，而没有方法体
2、抽象类：包含抽象方法的类叫抽象类，类包含一个或多个抽象方法，类必须是抽象的，否则编译器会报错；它是普通类和接口的中庸之道，
3、创建抽象类和抽象方法非常有用，能使共同的特性抽象起来，告诉用户和编译器如何使用他们。
4、接口也可以包含域，域是隐式的static和final
抽象类和接口的区别：
默认的方法实现 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现。

抽象类中可以有已经实现了的方法，也可以有被abstract修饰的方法（抽象方法），因为存在抽象方法，所以该类必须是抽象类。但是接口要求只能包含抽象方法，
抽象方法是指没有实现的方法。所以就不能像抽象类那么无赖了，接口就根本不能存在方法的实现。

实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。
它需要提供接口中所有声明的方法的实现。

抽象类虽然不能实例化来使用，但是可以被继承，让子类来具体实现父类的所有抽象方法。有点老子没完成的梦想交给儿子来完成，但是如果子类将抽象方法没有全部实现，
就必须把自己也修饰成抽象类，交于继承它的子类来完成实现。就相当于，儿子能力不够也没完成老爹的梦想，现在儿子等着再生儿子（被继承），然后让孙子去完成。
以此类推，直到没有抽象函数。

接口的实现，通过implements关键字。实现该接口的类，必须把接口中的所有方法给实现。不能再推给下一代。和抽象类相比，抽象类是将梦想传给家族，
一代一代去完成。那么接口就是掌门人找大师兄来完成帮派的鸿星伟业，这时候就只有一次希望，要么有能力就实现，没能力就不要接。

抽象类可以有构造器，而接口不能有构造器这个原因很简单，我们回到双方的定义上来，抽象类再怎么流氓无赖也好，终究是属于类，
就天生享有类的所有特性（但是不能实例化），当然包括类的构造方法，也就是构造器。但是接口是所有抽象方法的集合，注意，是集合，不是类。
当然没有构造方法一说，更别提什么构造器了。抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。
你不可以使用其它修饰符。抽象类的目的就是被继承，抽象方法就是为了被重写，所以肯定不能用private修饰符，肯定是可以用public的。
但是protected和default也是可以的。
接口就有且只有一个public修饰。（是不是感觉抽象类像小儿子各种耍无赖，接口就像私生子，说什么只能是什么）抽象类在java语言中所表示的是一种继承关系，
一个子类只能存在一个父类，但是可以存在多个接口。
java在类的继承上并没有多继承。抽象类属于类，所以可以被继承。但子类只能继承一个父类。java为了实现多继承，使用了接口。一个类可以实现多个接口。
继承就好比生了孩子，只能有一个爹，但是这个孩子可以学语文，学数学，学英语等等很多东西，而语文、数学、英语就相当于接口。总的来说，
因为java中抽象类只有单继承，接口就可以实现多继承。抽象方法比接口速度要快接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
记住抽象方法是小儿子，从小吃的好所以跑的快，接口是私生子，从小日子苦，营养不良。如果你往抽象类中添加新的方法，你可以给它提供默认的实现。
因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。

抽象类可以有一些非抽象方法的存在，这些方法被称为默认实现。如果添加一个默认实现方法（不能是抽象方法），就不需要在子类中去实现，
所以继承这个抽象类的子类无须改动。但是，接口中只能添加抽象方法，当你添加了抽象方法，实现该接口的类就必须实现这个新添加的方法。
因为，定义中说的很清楚，接口的实现必须实现所有的方法。所有，当然包括新添加的方法。

第十章 内部类
1、要想创建内部类的对象，不能直接引用外部类的名字，而是必须使用外部类的对象来创建该内部对象,在拥有外部类对象之前不可能创建内部类
2、匿名内部类与继承类有一些差别，要么实现接口，或者扩展类，不能两者兼备，也不能继承多个接口
3、匿名内部类实例初始化构造器，不能重载构造器
4、内部类常用在工厂模式
5、不想内部类和外部类有联系，将内部类设为static 即称之为嵌套类，，但非嵌套类不能有静态方法和变量，因为静态变量需要内存，而内部类需要外部类创建才能分配内存
6、内部类的class文件名称，A类含有内部类B A$B.class; A类中有内部类new B(){} 则对应的文件名称为 A$1.class
7、接口中的任何类都是public和static 所以其中可以加嵌套类
8、内部类最吸引人的原因：每个内部类都能独立继承自一个（接口）实现，无论其外部类是否已经继承了这个实现，对内部类都没影响
                    接口解决了部分问题，而内部类解决了多重继承问题，内部类可以继承多个非接口类型，（不是一个内部类）
9、继承后并不能重写其外围类中的内部类，是完全覆盖了；继承类中的内部类和父类的内部类是两个独立的个体
10、局部内部类 和 匿名内部类
   局部内部类不能有访问说明符，可以访问当前代码块内的常量以及此外围类的所有成员
   局部内部类与匿名内部类比较我们需要一个已命名的构造器，或者需要重载构造器； 匿名内部类只能用于实例初始化
11、闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。JAVA并不能显式地支持闭包，但是在JAVA中，闭包可以通过“接口+内部类”来实现。
   例如：一个接口程序员和一个基类作家都有一个相同的方法work，相同的方法名，但是其含义完全不同，这时候就需要闭包

第十一章 容器
1、ArrayList和LinkedList 都是按照插入元素的顺序保存对象的
   Set 保存对象的顺序没多大关系，用到的情况是一般看对象存不存在，HashSet 使用相当复杂的方式来存储元素，但它是最快获取元素的方式
    TreeSet是按照比较结果的升序方式排列元素，LinkedHashSet 是按照添加顺序保存元素
   HashMap 是使用一种非常快的算法来存储元素 TreeSet是按照比较结果的升序方式排列键，LinkedHashSet 是按照添加顺序保存键
2、基本的ArrayList 长于随机访问列表中的元素，而插入或者移除中间的元素较慢
   LinkedList 随机访问元素较慢，但特性集较ArrayList 更多
3、List 允许添加 移除元素，或者自我调整尺寸，正是它的重要价值所在
4、如果想确定一个元素存在于list中，使用contains()方法，如果想移除一个元素，使用remove()这个元素的引用，使用indexOf()来确定元素在list中的索引位置
5、subList 是从一个较大的列表中切出一个较小的列表，containAll 是检查一个集合是否完全包含在另一个大的集合中 retainAll() 是一种有效的交集操作，也依赖于equals()方法
6、isEmpty() 和 clear() 方法的效果 toArray() 将集合转化为数组，默认是没有类型检查的(Object)，可以在参数中指定元素类型，如果转化的数组长度超过了指定的数组长度，
   会自动创建一个合适长度的数组
7、Iterator remove方法可以移除由next()方法产生的最后一个元素，so 在调用remove方法之前得调用 next()
   迭代器统一了对容器的访问方式
8、LinkedList 常见方法
   getFirst() and element() are same; 如果list为空时，抛出NoSuchElement-Exception but peek() 在列表为空时返回null
   removeFirst() and remove() 移除并返回列表的头，果list为空时，抛出NoSuchElement-Exception but poll() 在列表为空时返回null
   addFist 插入元素到列表的头，add() 与 addLast() 相同
   removeLast() 移除并返回列表的最后一个元素
9、Set最常被使用的是测试归属性 HashSet使用的散列，TreeSet 是红黑树，
10、练习23 为什么出现次数最多的总是3呢？
11、队列在并发编程中相当重要
12、offer() 方法提供插入元素到queue的尾部，或者返回null
13、PriorityQueue<>() 是按照优先级的顺序取元素的，一般基本类型Character Double Integer String是按照自然排序做的
14、transient:
    Variables may be marked transient to indicate that they are not part of the persistent state of an object
    The transient keyword in Java is used to indicate that a field should not be part of the serialization
    (which means saved, like to a file) process.
15、类型参数<T>和无界通配符<?>的区别
    两种场景 1、声明一种泛型类或泛型方法  2、使用一种泛型方法或泛型类
    类型参数<T> 适合第一种场景，用来"约束类型一致的"
    无界通配符<?> 适合第二种
    声明泛型类不能用无界通配符<?>； 并且 <?> 使用中会有一些坑
    有界通配符<? extends XXX>，<? super XXX> 更实际和常用

16 总结：
   1）数组将数字和对象联系起来，保存类型明确的对象，可以是多维的，可以保存基本类型的数据，数组一旦生成，其容量就不改变
   2）Collection 保存单一的元素，Map保存相关联的键值对，通过java的泛型可以指定保存的对象类型，容器不能持有基本类型，但自动包装机制会自动的将
      基本类型进入容器时和包装器类型做双向转化
   3）List 是建立数字索引和对象的关联，因此，数组和List都是排好序的容器，List能够自动扩充容量
   4）进行大量的随机访问用ArrayList，过多的插入和删除则选择LinkedList
   5）各种Queue以及栈的行为 有LinkedList提供支持
   6）Set不支持重复元素，HashSet提供最快的查询速度，TreeSet使元素处于排序状态，LinkedHashSet 使元素以插入时的顺序排序
   7）Map是一种对象与对象相关联的设计，HashMap提供了最快访问速度，TreeMap使键始终处于排序状态，LinkedHashMap使元素保持插入顺序


第十二章
1、所有的标准异常类都有两个构造器，一个默认构造器，一个含参数
2、异常类的根类是Throwable，最好是抛出对应类型的异常，便于后续判断和处理
3、用抛出异常的方式从当前作用域退出 或者将异常对象返回给throw
4、异常有终止和恢复模型
5、异常说明：使用throws 接一个所有潜在异常列表 void f() throws TooBig, TooSmall, DivZero {...}
           代码必须与异常说明保持一致,说明后代码中必须包含这些异常
6、捕获所有异常 Exception 使用此异常就   不能包含太多信息
7、异常重新抛出
8、Throwable 这个Java类被用来表示任何可以作为异常被抛出的类，可分为两种类型，Error表示编译时和系统错误，Exception 是抛出异常的基本类型，
   所有的输入/输出异常都是从java.io.IOException 继承来的；
   属于运行时
9、如果RuntimeException 不被捕获而直达main()，那么程序退出前将调用异常的printStackTrace()
   请务必记住：只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型的异常处理都是由编译器强制执行的，究其原因，RuntimeException
   代表的是编程错误：
   1）无法预料的错误，比如你控制之外传递进来的null引用
   2）作为程序员，应该在代码中检查的错误（比如ArrayIndexOutOfBoundsException,得注意一下数组的大小了）在一个地方发生异常，常常在另一个地方
   导致错误；
10、在return中使用 finally
11、异常限制：当覆盖方法的时候，只能抛出在基类方法异常说明里列出的那些异常
            异常限制对构造器不起作用，继承类中的构造器可以抛出任何异常而不必理会基类构造器的异常
12、通过强制派生类遵守基类方法的异常说明，对象的可替换性得到了保证
13、如果异常发生了，所有的东西能被正确的清理吗？ 在大多数情况下是非常安全的，但涉及构造器时，构造器会把对象设置成安全的初始化状态，但还有别的动作
   比如打开一个文件，这个动作只有用户在对象使用完毕调用特定的清理方法才能得以清理，如果在构造器中抛出了异常，这些清理行为不一定会正常工作
14、抛出异常的时候，异常处理系统会按照代码的书写顺序找出"最近"的处理程序，找到匹配的处理程序后，他认为异常已经得到处理，然后就不再查找
    有时候并不要求抛出的异常处理程序与所声明的异常匹配，派生类的对象也可以匹配其基类的处理程序！

第十三章
1、String的+和+=是java仅有的两个重载过的操作符，而Java不允许程序员重载任何操作符
2、String还自带了一个非常有用的正则表达式工具 split()
3、replaceAll() replace() 也是用的正则匹配
4、abc+和(abc)+ 是有区别的
5、replaceAll() 和 replaceFirst() 用来替换普通的字符串，要想对这些字符串做特殊处理，这两个方法是无法胜任的，appendReplacement()
    此方法允许你在替换过程中对字符串做特殊处理！
6、检查String是否为int值
    /*Pattern pattern = Pattern.compile("[0-9]*");
    if (pattern.matcher(bucket.get(field).toString()).matches()) {
        continue;
    }*/

第十四章 类型信息
1、运行时类型信息可以使你在程序运行时发现和使用类型信息
2、你想在
3、使用newInstance()创建的类，必须带有默认的构造器
4、使用类字面常量对class进行引用，例如 FancyToy.class 这样不使用forName(); 简单安全，也更高效，在编译的时候检查错误。
   最重要的是不对类做初始化操作
   类字面常量不仅能引用普通的类，也可以应用到接口，数组以及普通的基本数据类型
   对于基本数据类型的包装器类，boolean.class 等同于 Boolean.TYPE
5、Class的转型语法 cast()可以将其参数转化为引用类型 这种很不常用，可以暂时忽略
6、类型检查 instanceOf x instanceof Dog 动态的instanceof Class.isInstance

7、参考 https://blog.csdn.net/fangqun663775/article/details/78960545
   静态代理类的缺点：单个代理类只能代理单个实现类，共同的接口增加方法后在代理类和实现类中都需要实现新增的方法，代码的重复性增加和维护成本增加
   动态代理是在运行时，通过反射机制实现动态代理，能够代理各种类型的对象，在Java中想要实现动态代理机制，需要java.lang.reflect.InvocationHandler接口
   和 java.lang.reflect.Proxy 类的支持
   java.lang.reflect.InvocationHandler接口的定义如下：
   //Object proxy:被代理的对象
   //Method method:要调用的方法
   //Object[] args:方法调用时所需要参数
   public interface InvocationHandler {
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
   }
   java.lang.reflect.Proxy类的定义如下：
   //CLassLoader loader:类的加载器
   //Class<?> interfaces:得到全部的接口
   //InvocationHandler h:得到InvocationHandler接口的子类的实例
   public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException
8、final 域实际上在接受修改时是安全的，系统运行时final域可以接受任何修改，但这些修改不会改变什么

第十五章 泛型
1、需要知道java的范型边界是什么，以及为什么会有这些限制，这能帮助你理解原理，根据经验，只有知道了边界你才能成为程序高手，而不必在死胡同里浪费时间
2、java泛型不能使用基本类型作为类型参数，但自动装箱拆箱的特性能实现自动转化
3、java的泛型推断只适合赋值操作，其它时候都不适用 如果你将一个泛型方法调用的结果作为参数，传递给另一个方法，该方法不会推断出这个类型，因为泛型方法的调用后的返回值是一个Object
4、泛型方法和可变参数列表能够很好的共存
5、泛型是运用擦除来实现的，所以List<String>和List<Integer>在运行时是相同的对象，都被擦除成原来的对象List了
6、不能创建泛型数组，使用ArrayList来代替 private List<T> genericArray = new ArrayList<>()
7、超类型通配符，可以声明通配符是有某个特定类的任何基类来界定的 <? super MyClass>
8、一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两种变体会成为相同的接口
9、自限定类型 public class Subtype extends BasicHolder<Subtype> { } 基类用导出类作为其参数

第十六章 数组
1、数组是一种效率最高的存储和随机访问对象引用序列的方式
2、无论哪种数组，数组标示符只是一个引用，指向在堆中创建的一个真实对象，这个数组保存的是其他对象的引用，基本类型是保存其值的
3、无法引用尚未初始化的数组
4、擦除会移除参数类型信息，而数组必须知道他们所持有的确切类型，强制保证类型安全
5、Arrays 有六个基本方法：equals() deepEquals()用于比较多维数组，fill() sort() binarySearch() 在已经排序的数组中查找元素，

第十七章 深入容器
1、最常见的未获支持的操作，都是源于背后由固定尺寸的数据结构支持的容器，当用Arrays.asList()时就会得到这样的容器，任何会引起对底层数据结构的尺寸的修改操作
都会产生UnsupportedOperationException的异常
2、SortedSet的意思是按照对象的比较函数对元素排序，而不是指元素插入的顺序，LinkedHashSet 是按插入顺序排的
3、

第十八章 Java I/O系统
1、无论我们何时使用readLine(), 都不应该使用DataInputStream 而应该使用BufferedReader 除了这一点 DataInputStream仍是I/O的首选
2、独立的类  RandomAccessFile是需要知道文件大小确切已知的类，
3、为了提高速度，对文件进行缓冲，对string或者File的引用传递给BufferedReader构造器
4、当我们使用DataOutputStream写数据时，能让DataInputStream读数据恢复字符串的唯一可靠做法是使用utf-8编码
5、按照标准的I/O模型，java提供了System.in System.out System.err
 System.out System.err 已经被包装成了 printStream 但System.in是一个未经包装和加工的InputStream
6、我们对标准输出，标准输入和错误I/O流进行重定向 setIn(InputStream) setOut(PrintStream) setErr(PrintStream)
7、速度的提高来自于所使用的结构更接近于操作系统的I/O工作方式：通道和缓冲器，唯一直接与通道交互的缓冲器是ByteBuffer;
8、transferTo()和transferFrom() 是直接将一个通道与另一个通道相连
9、ByteBuffer是以高位优先的方式存储数据
capacity() 返回缓冲区的容量
clear() 清空缓冲区，将position位置设置为0，limit设置为容量，可以调用此方法复写缓冲区
flip() 将limit设置为position，position位置置为零，此方法用于从缓冲区读取已经写入的数据
limit() 返回limit值
limit(int lim) 设置limit值
mark() 将mark设置为position
position() 返回position值
position(int pos) 设置position值
remaining() 返回（limit-position）的值
hasRemaining() 若有limit-position的值，则返回true
10、内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件,"映射文件访问" 可以显著的加快速度
11、引入了文件加锁机制，允许我们同步访问某个作为共享资源的文件！ 对独占锁和共享锁的支持由底层操作系统提供，
    如果操作系统不支持共享锁并未每个进程都创建一个锁，它就会使用锁
    可以通过FileLock.isShared() 来查询 可以根据position和limit加部分锁
    文件不能获取缓冲器里的锁，只能获取通道里的锁；

第二十章 注解
1、注解（也成为元数据）为我们代码中添加信息提供了一种形式化的方式，使我们在稍后某个时刻很方便的使用这些数据
   注解在一定程度上使将元数据与源代码结合起来，而不是外部文档保存数据造成的
2、在注解中，一般都会包含一些元素作为注解的值，当程序使用这些注解时，可以分析使用这些值，注解中的值更像接口中的方法，唯一的区别你可以为其指定默认值
   没有元素的注解称为标记注解
3、 @Target @Retention 注解的级别 @Documented 将此注解包含在Javadoc中 @Inherited 允许子类继承父类的注解
4、注解元素可用的类型有 所有基本类型(int, float, boolean ...)
                     String
                     class
                     Annotation
                     enum
                     以上类型的数组
5、在元素的代码定义还是默认赋值时都不能用null作为其值

第二十一章 并发编程
0、单处理器的线程会出现阻塞，所以才使得并发编程变得有意义
1、进程是运行在它自己的地址空间内的自包容的程序，
2、协作多线程，Java的线程是抢占式的，这表示调度机制会周期性的中断线程，并将上下文切换到另一个线程，从而为每个线程都提供时间片，使每个线程都分配到
数量合理的时间片去驱动它的任务
3、任何线程都可以启动另外的线程
4、java.util.concurrent 包中的执行器(Executor)将为你管理Thread对象，从而简化了并行编程，Executor为客户端和任务执行层提供了一个间接层
5、在任何的线程池中，现有的线程都能被复用
6、Runnable()不返回任何值，Callable是一个具有类型参数的泛型的接口，泛型参数表示的是call()的返回值
7、Thread类自身不执行任何操作，它只是驱动赋予它的任务
8、多线程的原子性操作和可见性，防着资源冲突的方式方式就是给资源加上锁
9、在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其它任务直接访问域，这样就会产生冲突
10、一个任务可以多次获得对象的锁，JVM负责跟踪对象被加锁的次数，只有首先获得了锁的任务才能继续获取多个其它锁，当任务离开了synchronized的方法，
  则计数减 1，当计数为0时，此时别的任务就可以使用此资源
11、如果对象中有超过一个方法在处理临界数据，则必须同步所有使用此资源的方法，只同步一个方法，那么其它方法则会忽略掉这个资源锁，并可以在无任何惩罚
的时候被调用，
12、需要解决特殊问题时，才使用显式的Lock对象，例如用Synchronized关键字获取锁不能失败重试，不能设置超时
13、原子性操作可以应用于除long和double之外的基本类型的简单操作，对于读取和写入除了long和double之外的基本类型变量这样的操作，是当作一个原子去操作
去操作内存的，但是JVM可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了在读取和写入操作中间发生上下文切换
从而导致不同的任务看到不正确结果的可能性！当你定义long和double类型时，如果设置了volatile关键字就会获得原子性
14、volatile 还保证了在应用中的可视性，如果你将一个域声明为volatile，则一个任务对这个域的写操作，所有读任务都对这个修改是可见的，
即便使用了本地缓存，情况也确实如此，volatile域会立即写入到主存中，而读取操作就发生在主存中
15、理解原子性和易变性是不同的概念这一点很重要，在非volatile域上的原子操作不必刷新到主存中去，因此其它任务读取该域就应该是volatile的，否则
就应该使用同步编程
16 使用synchronized(syncObject){} 修饰的代码称为临界区，此synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制
synchronized块必须给定一个在其上同步的对象
17、如果使用synchronized(this)获得了其上了锁，那么该对象其它的synchronized修饰的方法和临界区就不能被访问
18、任务进入阻塞状态，有如下几个原因：
    1> 通过调用sleep(milliseconds) 使任务进入休眠状态
    2> 你通过调用wait()使线程挂起，然后在后面中调用notify()和notifyAll()消息，线程就会进入就绪状态，
    3> 线程等待某个输入/输出完成
    4> 任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁
19、Thread.interrupted() 提供离开run里的循环而不抛出异常的方式，为了调用interrupt，你必须持有Thread对象，但新的concurrent尽量避免直接对
    Thread操作，转而尽量对Executor来执行这类操作，如果你在Executor调用shutdownNow() 它将发送一个interrupt()来给这个executor启动的所有
    线程， 如果只希望中断单个的任务，那么使用Executor的submit()来启动任务，它会返回一个Future<?>的泛型对象那么就有了对这个任务的控制权，
    使用这个Future的关键在于你在其上可以调用cancel()
20、你不能中断试图获得synchronized锁和执行I/O操作的线程，特别在创建执行I/O任务时，意味这I/O操作有潜在锁住你多线程程序的可能
    对于这类问题，一个略显笨拙但行之有效的方式就是关闭启动这个任务的底层资源
21、任务被互斥所阻塞
22、可以通过调用interrupted()来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，还可以清除中断状态，可以经由单一的InterruptedException
或单一成功的Thread.interrupted()测试来得到这种通知
23、wait() 会在等待外部事件变化的过程中将任务挂起，不能在任务循环的检查文件状态，不断的空循环，这种称为忙等待，只有在notify或notifyAll()
产生了某些感兴趣的事物，这个任务才会被唤醒并去检查所发生的变化，
24、调用sleep()和yield()时任务的锁不会释放，而接受毫秒数参数的wait()与sleep()不同的是：在wait期间锁是释放的，并可以被notify和notifyAll,或者设置的wait时间
到了之后自动唤起；第二种更常用的是不接受任何参数的wait()，启动了就无限挂起只等到notify或notifyAll()
25、检查所感兴趣的特定条件，在条件不满足的情况下返回wait(),惯用的方法就是使用while来实现
26、使用notify()时，当条件发生变化时，应该保证只有一个等待的任务受益，而这些限制必须对所有可能存在的子类都必须总是起作用的，以上所有的条件有一项
不满足都只能使用notifyAll()
27、发生死锁的四个条件：
    1、互斥条件，任务使用的资源至少有一个是不能共享的，一根Chopstick只能被一个Philosopher使用
    2、一个任务持有一个资源并等待另一个任务需要释放的资源，一个持有一根Chopstick的Philosopher必须等另外一个Philosopher手中释放
    3、资源不能被抢占，任务必须把释放资源当作普通事件
    4、必须有循环等待

