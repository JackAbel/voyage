第一章 对象导论
1、我们将问题空间的元素以及其在解空间的表示称为 对象
2、类实际上就是数据类型
3、设计难点：问题空间的元素和解空间的对象创建一对一的关系
4、UML图 统一建模类型
5、当你开发一个程序设计是，最好的方法是把对象当作 “服务提供者”
6、高内聚是软件设计的基本质量要求之一
7、访问控制 （1）可以让客户端程序员无法触及隐藏的部分；（2）可以让库设计者可以任意调整后 台程序设计而不影响客户端的使用；
8、projected与private作用相当，projected 只是在继承中可以被引用
9、一个非面向对象编程的编译器产生的函数调用运用前期绑定，编译器将会产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行代码的绝对地址
     面向对象编程使用了后期绑定，当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确认调用方法的存在，检查调用参数和返回值的类型。
     ******特殊代码使用在对象中存储的信息来计算方法体的地址****** java中方法的动态绑定时默认的

10、容器选择：（1）不同的容器提供了不同的接口和外部行为
                           (2) 不同的容器执行某些操作时会有不同的效率
11、堆中动态管理存储空间，在运行时需要对象才去分配空间，而不是编译时在堆栈中创建对象，分配内存可能比创建对象更耗时！
12、垃圾回收器提供了更高层的保障，避免了内存泄漏问题（Wikipedia 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。
    内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费）

第二章 一切都是对象
1、存储数据的地方：寄存器，堆栈，堆，常量存储，非RAM存储
    堆栈：位于通用RAM；指针下移分配新的内存，上移释放内存 创建程序时，Java系统必须知道存储在堆栈中所有项的生命周期，限制了语言的灵活性，
    某些java数据存储在对象中--特别时对象引用 Java对象不存在其中
存储基本类型（变量直接存储值）
    堆：通用的内存池，存放所有的Java对象
    非RAM存储：流对象和持久化对象
2、若返回值为空，则return 的作用就是用来退出方法而已
3、static 解决了只想为某特定域分配单一内存空间；而不去关注究竟要创建多少对象。
                 方法不与关联它的对象实例产生关系，没有创建对象，也能调用这个方法
4、javadoc 文档格式化工具
5、自动包装器对基本类型和包装器类型自动装箱

第三章 操作符
1、System.out.println*() 这种特定上下文环境中 String类型的 + 操作连接，意味着”字符串连接“，会自动将非String的转化为 String
2、基本类型赋值是存储了实际的数值，而并非指向一个对象的引用，为其赋值的时候是直接将一个数从一个地方复制到另外一个地方，
3、如果在应当使用String值的地方使用了布尔值，则boolean类型的值会相应的转变为文本类型
4、按位操作符 (&) 两个输入位都是1，则输出1 否则输出0；按位操作符（|）有一个是1 输出1，按位异或(^) 其中一个是1，但不全是1则输出1 按位非 取反操作。
可以和=号联合操作，&=, |=, ^= 都是合法的
5、<<有符号左移 >>有符号右移（右移时符号为-时，高位补1）
6、三元操作符 if-else boolean-exp?value1:value2
7、类型转换运算符允许我们显式地进行这种类型转化；但窄化转化是不被允许的，除布尔型的基本类型都能进行类型转化

第四章 控制执行流程
1、重载表示相同的方法名可以具有不同的参数列表
2、如果方法是void的，那么方法体内就会相应有一个隐式的return，所以不是所有的方法都要写return
3、1> 一般情况下continue会回退到最内层循环的开头，继续执行循环
   2> 带标签的continue会进入到达标签的位置，并重新进入哪个标签后面的循环
   3> 一般break会中断并跳出当前循环
   4> 带标签的break会中断并跳出标签所指的那个循环

第五章 初始化和清理
1、当创建了一个对象时，也就给此分配到的存储空间取了一个名字
2、构造器方法重载 方法重载，以参数的方式
  不能以返回值的方式重载方法，因为写一个方法名不知道调用哪一个
3、在构造器中调用构造器 可以用this调用构造器，但不能调用两个，必须将构造器置于最起始处
   在类定义中，除构造器外，编译器禁止类内其它任何方法调用构造器
4、static 方法内部是不能调用非静态方法的，反之可以
5、初始化的顺序是静态对象 后是非静态对象。

6、1）对象可能不被垃圾回收
   2）垃圾回收不等同于析构
   3）垃圾回收只与内存有关
7、垃圾回收器对于提高对象的创建速度，有明显的效果。堆内一面回收空间，一面使对象可以紧凑排列。
8、对象引用计数的为零的回收缺陷：对象之间存在循环引用，可能会出现“对像应该被回收，但引用不为零的情况”
   对垃圾回收器而言，定位这样的交互引用对象组所需的工作量极大。
9、垃圾回收器的另外一种模式，对任何活的对象，一定能最终追溯到其存活在堆栈或静态存储区中的引用 ，当完全没引用时回收（解决了对象交互引用的缺陷）
   对此垃圾回收器将采用自适应的垃圾回收技术，如何找到存活的对象则取决于具体的java虚拟机实现。
   自适应的，分代的，停止-复制，标记-清扫式垃圾回收器
即时编译器和惰性评估（即时编译器在必要的时候才对对象进行编译）
10、对象的创建过程：
 1-定位dog.class 文件
 2-载入Dog.class（这将创建一个class对象） 有关静态初始化的所以动作都会执行，静态初始化只在Class对象首次加载时进行一次
 3-当用new Dog() 创建对象时，会在堆上为其分配足够的内存空间
 4-这块存储空间会被清零，类中引用到的所有的基本类型会设置为默认值，而引用则设置为null
 5-执行所有出现在字段定义处的初始化动作
 6-执行构造器
11、静态子句 static {}; static 不能应用在局部变量，例如main方法中
12、枚举的方法 ordinal()表示特定常量的声明顺序 static values()按照enum常量的声明顺序，产生由这些常量值构成的数组

第六章 访问权限控制
1、包内包含有一组类，它们在单一的名字空间内被组织在一起
2、每个编译单元只能有一个public类
3、protected 也有包内访问权限
4、
第七章 复用类
1、方法重载（Override）的子方法必须和父方法同名称 返回类型 形参(除协变返回类型外)
2、一个即是static又是final的域只占据一段不能改变的存储空间
3、final 修饰的方法 第一 防止继承类修改父类方法的含义，覆盖也不可以（在明确需要禁止覆盖时才写，会降低执行效率）
4、final 类不能被继承（一般出于严格的安全考虑才会选择final修饰类）
5、类的代码在初次使用时才会被加载
6、总结：程序开发是一个增量过程，犹如人类的学习一样，程序开发是依赖于实验，你只能尽可能的去计算所有可能发生的结果，
       而不能将所有的结果都拿到，项目视为一个有机的、进化的生命体。

第八章 多态

1、多态是分离做什么和怎么做，从另一个角度将接口和实现分离出来，不同类型根据实现方法的不同运行时有不同的动作
   作用是消除不同类型间的耦合。
2、java 中除了static和final（private算final）方法外，其他方法都默认是后期绑定（运行时绑定）
3、域与静态方法不能用多态
4、域访问操作由编译器解析，所以不具有多态性 通常将基类中的域设置为private，因此不能直接访问他们，只能通过方法来访问
5、在构造器内部调用导出类覆盖的方法时，方法内用到的成员变量还未初始化，可能会导致错误
6、初始化的实际进程：1> 先会给对象分配的存储空间初始化成二进制的零
                 2> 调用基类构造器，
                 3> 按照声明的顺序调用成员的初始化方法
                 4> 调用导出类的构造器主体
7、构造器实际上是隐式的static方法

第九章 接口
1、抽象方法是仅有方法名，而没有方法体
2、抽象类：包含抽象方法的类叫抽象类，类包含一个或多个抽象方法，类必须是抽象的，否则编译器会报错；它是普通类和接口的中庸之道，
3、创建抽象类和抽象方法非常有用，能使共同的特性抽象起来，告诉用户和编译器如何使用他们。
4、接口也可以包含域，域是隐式的static和final
抽象类和接口的区别：
默认的方法实现 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现。

抽象类中可以有已经实现了的方法，也可以有被abstract修饰的方法（抽象方法），因为存在抽象方法，所以该类必须是抽象类。但是接口要求只能包含抽象方法，
抽象方法是指没有实现的方法。所以就不能像抽象类那么无赖了，接口就根本不能存在方法的实现。

实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。
它需要提供接口中所有声明的方法的实现。

抽象类虽然不能实例化来使用，但是可以被继承，让子类来具体实现父类的所有抽象方法。有点老子没完成的梦想交给儿子来完成，但是如果子类将抽象方法没有全部实现，
就必须把自己也修饰成抽象类，交于继承它的子类来完成实现。就相当于，儿子能力不够也没完成老爹的梦想，现在儿子等着再生儿子（被继承），然后让孙子去完成。
以此类推，直到没有抽象函数。

接口的实现，通过implements关键字。实现该接口的类，必须把接口中的所有方法给实现。不能再推给下一代。和抽象类相比，抽象类是将梦想传给家族，
一代一代去完成。那么接口就是掌门人找大师兄来完成帮派的鸿星伟业，这时候就只有一次希望，要么有能力就实现，没能力就不要接。

抽象类可以有构造器，而接口不能有构造器这个原因很简单，我们回到双方的定义上来，抽象类再怎么流氓无赖也好，终究是属于类，
就天生享有类的所有特性（但是不能实例化），当然包括类的构造方法，也就是构造器。但是接口是所有抽象方法的集合，注意，是集合，不是类。
当然没有构造方法一说，更别提什么构造器了。抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。
你不可以使用其它修饰符。抽象类的目的就是被继承，抽象方法就是为了被重写，所以肯定不能用private修饰符，肯定是可以用public的。
但是protected和default也是可以的。
接口就有且只有一个public修饰。（是不是感觉抽象类像小儿子各种耍无赖，接口就像私生子，说什么只能是什么）抽象类在java语言中所表示的是一种继承关系，
一个子类只能存在一个父类，但是可以存在多个接口。
java在类的继承上并没有多继承。抽象类属于类，所以可以被继承。但子类只能继承一个父类。java为了实现多继承，使用了接口。一个类可以实现多个接口。
继承就好比生了孩子，只能有一个爹，但是这个孩子可以学语文，学数学，学英语等等很多东西，而语文、数学、英语就相当于接口。总的来说，
因为java中抽象类只有单继承，接口就可以实现多继承。抽象方法比接口速度要快接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
记住抽象方法是小儿子，从小吃的好所以跑的快，接口是私生子，从小日子苦，营养不良。如果你往抽象类中添加新的方法，你可以给它提供默认的实现。
因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。

抽象类可以有一些非抽象方法的存在，这些方法被称为默认实现。如果添加一个默认实现方法（不能是抽象方法），就不需要在子类中去实现，
所以继承这个抽象类的子类无须改动。但是，接口中只能添加抽象方法，当你添加了抽象方法，实现该接口的类就必须实现这个新添加的方法。
因为，定义中说的很清楚，接口的实现必须实现所有的方法。所有，当然包括新添加的方法。

第十章 内部类
1、要想创建内部类的对象，不能直接引用外部类的名字，而是必须使用外部类的对象来创建该内部对象,在拥有外部类对象之前不可能创建内部类
2、匿名内部类与继承类有一些差别，要么实现接口，或者扩展类，不能两者兼备，也不能继承多个接口
3、匿名内部类实例初始化构造器，不能重载构造器
4、内部类常用在工厂模式
5、不想内部类和外部类有联系，将内部类设为static 即称之为嵌套类，
6、内部类的class文件名称，A类含有内部类B A$B.class; A类中有内部类new B(){} 则对应的文件名称为 A$1.class
7、接口中的任何类都是public和static 所以其中可以加嵌套类
8、内部类最吸引人的原因：每个内部类都能独立继承自一个（接口）实现，无论其外部类是否已经继承了这个实现，对内部类都没影响
                    接口解决了部分问题，而内部类解决了多重继承问题，内部类可以继承多个非接口类型，（不是一个内部类）

